'''

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


'''
# Functional style

def fibonacci_sequence(max_value):
    a,b = 0,1
    while a < max_value:
        yield a
        a,b = b,a + b

fib_result_functional = sum(filter(lambda x: x % 2 == 0, fibonacci_sequence(4000000)))
print("the sum of fibonacci sequence of 4000000 in functional style: ", fib_result_functional)


# Imperative stype

def fibonacci_while(max_value_1):
    a,b = 0,1
    sequence = []
    while a < max_value_1:
        sequence.append(a)
        a,b = b,a + b
    return sequence

result_while = sum(filter(lambda x: x % 2 == 0, fibonacci_while(4000000)))
print("Fibonacci with while loop: ", result_while)


def fibonacci_for(max_value_2):
    sequence_2 = [0,1]
    for i in range(2, max_value_2):
        sequence_2.append(sequence_2[i-1] + sequence_2[i-2])
        if sequence_2[-1] >= max_value_2:
            break
    return sequence_2[:-1]

result_for = sum(filter(lambda x: x % 2 == 0, fibonacci_for(4000000)))
print(" fibonacci with for loop: ", result_for)

# Declerative style

# Using reqursion

def fibonacci_sequence_recursion(n):
    if n <= 1:
        return n
    return fibonacci_sequence_recursion(n-1) + fibonacci_sequence_recursion(n-2)

def fibonacci_seqnence_declerative(max_value_declerative):
    return [fibonacci_sequence_recursion(i) for i in range(max_value_declerative) if fibonacci_sequence_recursion(i) < max_value_declerative]

result_declerative = sum(filter(lambda x: x % 2 == 0, fibonacci_seqnence_declerative(4000000)))

print(" Declerative result of fibonacci: ", result_declerative)


